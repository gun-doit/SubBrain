> **C언어에 여러 가지 기능을 추가하여 만든 프로그래밍 언어**
> 
> **절차 지향 및 객체 지향적 언어**

> **범위 지정 연산자 ( scope resolution operator )**

**가장 우선순위가 높은 연산자 ( :: )**

**여러 범위에서 사용된 식별자를 식별하고 구분하는데 사용하는 연산자이다.**

1. **::식별자**
2. **클래스이름::식별자**
3. **네임스페이즈::식별자**
4. **열거체::식별자**

  

> **멤버 포인터 연산자 ( pointer-to-member operator )**

**클래스의 멤버를 가리키는 포인터를 정의할 수 있으며 두 가지의 형태가 있다.**

1. **왼쪽의 피연산자가 클래스 타입의 객체인 경우 : .***
2. **왼쪽의 피연산자가 클래스 타입의 객체를 가리키는 포인터인 경우 : →***

문법

1. **클래스타입의 객체.*멤버이름**
2. **클래스타입의객체의포인터→*멤버이름**

  

### Namespace

- **이름이 기억되는 영역을 뜻하며, 이름이 소속된 공간을 의미한다.**
- **C++프로그램을 작성할 때 발생하는 이름에 대한 충돌을 방지해 주는 방법을 제공한다.**

**→ iostream 헤더의 내용들은 std namespace를 가지고 있다.**

### Symbolic constant ( 심볼릭 상수 )

- **변수와 마찬가지로 이름을 가지고 있는 상수**
- **const 키워드를 사용해 선언할 수 있다.**

**장점**

1. **상수의 타입을 명시적으로 지정할 수 있다.**
2. **구조체와 같은 복잡한 사용자 정의 타입에도 사용할 수 있다.**
3. **해당 심볼릭 상수를 특정 함수나 파일에서만 사용할 수 있도록 제한할 수 있다.**

  

### 실수 표현 방식

1. **고정 소수점 ( fixed point ) 방식**
    
    ![[Untitled 23.png|Untitled 23.png]]
    
    **소수부의 자릿수를 미리 정하여, 고정된 자릿수의 소수를 표현하는 것**
    
    **소수부의 자릿수가 크지 않으므로, 표현할 수 있는 범위가 매우 적다라는 단점이 있다.**
    
2. **부동 소수점 ( floating point ) 방식**
    
    **실수는 보통 정수부와 소수부로 나뉘지만, 가수부와 지수부로 나누어 표현할 수 도있다.**
    
    **아래와 같은 수식을 사용하여 매우 큰 실수까지 표현할 수 있다.**
    
    ### 수식
    
    ±(1.가수부)×2지수부-127
    

  

**C++의 부동 소수점 표현 방식**

1. **3.14, -45.64과 같이 소수 부분을 가지는 아라비아 숫자로 표현한다.**
2. **e 또는 E를 사용하여 지수 표기법으로 사용한다.**

![[Untitled 1 11.png|Untitled 1 11.png]]

![[Untitled 2 4.png|Untitled 2 4.png]]

- **공백 포함 문자열 입력**
    
    1. **getline**
    
    ```C++
    int main(){
    	string s;
    	getline(cin,s);
    	cout << s;
    }
    ```
    
    1. **cin.getline**
    
    ```C++
    int main(){
    	char s[100];
    	cin.getline(s,100,'\n');
    	cout << s;
    }
    ```
    
    1. **gets_s**
    
    ```C++
    int main(){
    	char s[100];
    	gets_s(s,sizeof(s));
    	cout << s;
    }
    ```
    

- **new int vs int[N]**
    
    ```C++
    1. int *arr = new int[N];
    
    2. int arr[N];
    ```
    
    1. **new int[N] : 힙(heap)에 동적으로 할당 - 동적할당**
    2. **int arr[N] : 스택(stack)에 할당. - 동적할당은 맞음**
    
    ---
    
    - **프로그램이 사용하는 메모리는 일반적으로** **==[세그먼트](https://boycoding.tistory.com/235)==** ==**라고 하는 몇 가지 다른 영역으로 나뉜다.**==
    
    > **코드 세그먼트**
    
    **컴파일된 프로그램이 저장되는 영역, 일반적으로 read-only**
    
    ---
    
    > **힙 세그먼트 (Heap segment)**
    
    동적으로 할당된 변수가 할당되는 영역
    
    ```C++
    int *ptr= new int ; // 4 바이트 할당
    int *array = new int[10]; // 40 바이트 할당
    ```
    
    > [!important]  
    > 메모리 요청이 순차적 메모리 주소를 할당하는 결과가 아닐 수 있다.  
    
    - **비교적 느림**
    - **할당된 메모리는 명시적으로 할당 해제하거나 종료될 때까지 유지**
    - **동적으로 할당된 메모리는 포인터를 통해 접근 : 포인터를 역참조하는 것은 변수에 직접 접근하는 것보다 느리다**
    
    ---
    
    > [[콜 스택(Call Stack)]]
    
    **함수 매개 변수, 지역 변수 및 기타 함수 정보가 저장되는 영역**
    
    LIFO 자료구조로 함수 호출이 끝나고, 이전 함수로 돌아갈 때 이 함수의 바로 이전 함수로 돌아가야 한다.
    
    ---
    
    > **데이터 세그먼트**
    
    **전역 변수 및 정적 변수가 저장되는 영역**
    
    ---
    

[[ios_base…]]

[[C++ 컴파일]]

[[콜 스택(Call Stack)]]

[[String]]