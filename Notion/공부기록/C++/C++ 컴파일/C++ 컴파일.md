## 과정

1. \#include와 \#define 와 같은 전처리기 매크로들을 처리하는 **전처리(Preprocessing) 단계**
2. 소스 파일 → 어셈블리 파일로 변환하는 **컴파일 단계**
3. 어셈블리 코드 → 기계어로 이루어진 목적 코드(Object file)로 변환하는 **어셈블리 단계**
4. 목적 코드를 한데 모아 실행 파일로 만들어주는 **링킹 단계**

![[Untitled 44.png|Untitled 44.png]]

![[Untitled 1 19.png|Untitled 1 19.png]]

**(컴파일 단계 + 어셈블리 단계 + 링킹 단계) 를 묶어 컴파일 단계라고도함**

---

- **전처리 단계**
    
    ### **Phase 1 : 문자들 해석하기**
    
    c++에선 기본적으로 총 96개의 문자들로 이루어진 Basic source character set이 있음.
    
    - 5 종륭의 공백 문자 ( 공백, 수평탭, 수직탭, 폼 피드, 새 줄) [ [링크](https://en.cppreference.com/w/cpp/language/translation_phases) ]
    - 10 종류의 숫자 (0 - 9)
    - 52 종류의 알파벳 대소문자
    - 29 종류의 특수 문자들( _, { , + 등_)
    
    ==**기본 문자 셋에 없는 문자들은 \u를 통해 유니코드 값으로 치환되거나, 컴파일러에 의해서 따로 해석됨.**==
    
    ---
    
    ### **Phase 2 : \ 문자 해석하기**
    
    ‘\’ 문자가 문장 맨 끝 부분에 있다면, 해당 문장과 바로 다음에 오는 문장이 하나로 합쳐지고 개행 문자는 삭제된다.
    
    **==abc def → abcdef==**
    
    ---
    
    ### **Phase 3 :** [**전처리 토큰**](https://eel.is/c++draft/lex.pptoken)**들로 분리하기**
    
    소스 파일을 주석(comment), 공백 문자, **전처리 토큰(Preprocessing token)**들로 분리하는 단계.
    
    - 헤더 이름 ( <iostream> 과 같이 )
    - 식별자
    - 문자/문자열 리터럴
    - 연산자들( +, ## )
    
    이 단계에서 raw string literal을 확인해서 만일 1~2 단계를 거치면서 해당 문자열 안의 내용이 바뀌었다면 변경이 취소됨.
    
    주석은 모두 공백 문자 하나로 변경된다.
    
    **컴파일러는 전처리기 토큰을 인식할 때에는 가능한 가장 긴 전처리 토큰을 만드려고한다. 이걸** ==**maximal munch**== **라고 함**
    
    ==**int a = bar+++++baz**== ==**→**====  
      
    ==사람의 의도 = **bar++ + ++baz**이지만  
    컴파일러 =  
    **bar++ ++ +baz**로 해석되서 오류가 발생한다
    
    ==**int bar = 0xE+foo**== ==**→  
    사람 의도 = 0xE + foo  
    컴파일러 = 0xE+ foo**====로 해석해서 오류가 발생 ( 부동 소수점 리터럴의 경우 E를 통해 지수를 지정할 수 있기 때문에 )==
    
    ---
    
    ### **Phase 4 : 전처리기 실행 단계**
    
    \#include에 지정된 파일의 내용을 복사합니다.
    
    \#define에 정의된 매크로를 사용해서 치환합니다.
    
    \#if, \#ifndef 와 같은 구분들을 실행해서 코드를 치환합니다.
    
    \#pragma 와 같은 컴파일러 명령문을 해석합니다.
    
      
    
    **중복되어 include되더라도 괜찮음 ㅋ → 헤더 가드(Header guard)를 작성하기 때문에**
    
    ```C++
    # "a.h"
    \#ifndef A_H
    \#define A_H
    
    class A{};
    \#endif
    
    # "main.cpp"
    \#include "a.h"
    \#include "a.h"
    
    int main(){}
    ```
    
    위와 같이 코드가 있더라고 헤더 가드가 작동하여
    
    ```C++
    \#ifndef A_H
    \#deficne A_H
    
    class A{};
    \#endif
    \#ifndef A_H
    \#define A_H
    
    class A {};
    \#endif
    int main() {}
    ```
    
    로 변경되지만 첫번째 ifndef에서는 A_H가 정의되어 있지 않기 때문에 사라지지 않지만, 두 번째 ifndef 에서는 A_H가 정의되어 있으므로 \#ifndef와 \#endif 사이의 모든 내용들이 개행 문자로 치환된다.
    
    ```C++
    class A {};
    
    int main() {}
    ```
    
    로 치환된다.
    
    ### ==**\#include 로 복사된 헤더 파일은 다시 Phase 1 - 4단계를 거치며, 소스파일에 더이상 전처리기문이 없을 때 까지 지속된다.**==
    
    > [!important]  
    > 굉장히 비효율 적이다.. Precompiled header라는 개념이 도입 되었지만 사용시에 몇 가지 제약이 있다.C++20 에서는 모듈(module) 이라는 개념을 도입해서 이와 같은 문제를 해결할 수 있습니다. 모듈은 다른 파일의 클래스의 함수들을 참조할 수 잇지만 \#include 를 할때 처럼 해당 파일의 모든 내용을 불러오지는 않는다.  
    
    ---
    
    ### Phase 5 : 실행 문자 셋으로 변경하기
    
    모든 문자들은 이전의소스 코드 문자 셋에서 실행 문자셋(Execution character set) 의 문자들로 변경된다. 마찬가지로 이전의 Escaped 된 자들도 실행 문자 셋의 문자들로 변경된다.
    
    ---
    
    ### Phase 6 : 인접한 문자열 합치기
    
    인접한 문자열들이 하나로 합쳐진다.
    
    **std::cout << “abc”  
      
    ****“def”;**
    
    의 경우
    
    **std::cout << “abcdef”;**
    
    로 변경된다.
    
- **컴파일 단계**
    
    > **컴파일 과정에서는 앞서 생성되었던 전처리기 토큰들을 바탕으로 실제 컴파일 토큰을 생성하여 분석하게 된다.**
    
    ### Phase 7 : 해석 유닛 생성 (Translation Unit)
    
    전처리기 토큰들이 컴파일 토큰으로 변환이 되고, 컴파일 토큰들은 컴파일러에 의해 해석되어서 해석 유닛(Translation Unit - **TU**)을 생성하게 된다.
    
    > [!important]  
    > C++ 프로그램의 컴파일 단위, 보통 하나의 소스 파일과 해당 파일에 포함된 헤더 파일들을 합친 것을 의미. — 각 .cpp 파일 마다 한개의 TU가 생성된다고 보면된다. by GPT  
    
    **소스파일 별로 하나 씩 존재**
    
    ---
    
    ### **Phase 8 : 인스턴스 유닛 생성 (Instantiton Unit)**
    
    컴파일러는 생성된 TU를 분석해서 필요로 하는 템플릿 인스턴스들을 확인한다. 템플릿들의 정의 위치가 확인 되면 해당 템플릿들의 인스턴스화가 진행되고 이를 통해서 인스턴스 유닛이 생성된다.
    
    이 단계를 마치면 **목적 코드** 를 생성할 수 있게 된다.
    
- **링킹 (Linking)**
    
    컴파일러가 생성한 목적 파일들과 외부 라이브러리 파일들을 모아서 실행 파일을 생성.
    
      
    
      
    

---

## 정의 (Definition) 와 선언 (Declaration)

### 선언 : TU에 새로운 이름을 도입하거나, 기존에 선언된 이름을 재선언 하는 것

  

**int f(); → f 라는 함수를** ==**선언**== **한것.**

**int a; → a라는 int 변수를** ==**정의**== **한 것.**

**int f() { return 0; } → f라는 함수를** ==**정의**== **한것.**

**class A; → A를** ==**선언**==

**class A {}; → A를** ==**정의**== **((??))**

일반적인 변수의 경우 선의와 정의는 동일하지만 extern 지정자가 들어간 경우 명시적으로 초기화 되지 않는다면 선언이다

**extern const int a →** ==**선언**==**  
extern const int b = 1 →  
**==**정의**==

클래스 정의 내부에 inline이 아닌 static 멤버의 경우 정의

**struct S{  
int n; → S::n 정의  
static int i; → S::i 선언  
inline static int x; → S::x 정의  
}; → S 정의  
int S::i; → S::i 정의  
**

### 유일 정의 규칙 ( ODR )

> **각 TU에 존재하는 모든 변수, 함수, 클래스, enum, 템플릿 등등의 정의(Definition) 는 유일해야하고 inline이 아닌 모든 함수의 변수들의 정의는 전체 프로그램에서 유일해야 한다.  
> 유일 정의 규칙( One Definition Rule - 줄여서 ODR ) 이라고 한다.  
> **

→ **TU 안에 같은 선은은 여러개 있어도 괜찮다 라는 의미**

```C++
// 문제없음
int f();
int f();
int f();

int main() {]
```

```C++
//문제 없음
int f(){
	return 0;
}

int f();
int f();
int main() {}
```

```C++
int f(){       // f의 정의
	return 0;
}

int f(){       // ODR 위반
	return 0;
}

int f();       // f 의 선언
```

→ **inline이 아닌 모든 함수의 변수들의 정의는 전체 프로그램에서 유일 해야 한다.  
⇒ inline 으로 정의 되지 않은 모든 함수들과 변수들의 경우 프로그램을 구성하는 모든 TU에서 정의가 단 하나 있어야 한다. 반면 inline 인 변수나 함수의 경우 이를 사용하고자 하는 TU 안에 반드시 정의되어 있어야 한다.  
**

```C++
// TU 1
int f();

// TU 2
int f(){
	return 0;
}
// ODR 위반이 아니다.


//반면
// TU 1
int f(){
	return 1;
}

// TU 2
int f(){
	return 0;
}
//ODR 위반.
```

  

---

1) [컴파일에 대해](https://sanghoon23.tistory.com/74)

2) [링킹](https://sanghoon23.tistory.com/75)

[[inline 키워드]]