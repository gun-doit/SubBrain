  

> **풀이**

**전형적인 DP 문제로 “순서만 다른 것은 같은 것”으로 본다는 것만 유의해서 풀면된다.**

기존에 풀던 방식

```C
dp[0] = 0;
dp[1] = 1; // dp[0](+1) + 1(1로 만듬);           1
dp[2] = 2; // dp[1](+1) + 1(2);                  11, 2
dp[3] = 4; // dp[2](+1) + dp[1](+2) + 1(3);      111, 21, 12, 3
dp[4] = 7; // dp[3](+1) + dp[2](+2) + dp[1](+3); 1111,211,121,31,112,22,13
```

**⇒ 위와 같은 오류를 해결하기 위해 마지막에 더해준 숫자를 2차원 배열로 생성해봄**

# CODE

```C

int dp[10001][4];

void solution(){
    for(int n = 4; n<=10000; ++n){
        dp[n][1] = dp[n-1][1]; // 1뒤에 1만옴
        dp[n][2] = dp[n-2][1] + dp[n-2][2]; // + 1하는 경우와 + 2하는 경우
        dp[n][3] = dp[n-3][1] + dp[n-3][2] + dp[n-3][3]; // + 1, + 2, + 3;
    }
}
```